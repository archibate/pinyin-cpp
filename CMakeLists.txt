cmake_minimum_required(VERSION 3.18)

if (NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Release)
endif()
set(CMAKE_CXX_STANDARD 20)

project(main LANGUAGES CXX)

function (target_resources target namespace header visibility)
    set(header_content "#pragma once\n/* generated by CMakeResource */\n#include <string>\n#include <string_view>\n#include <sstream>\nnamespace ${namespace} {\nstruct CMakeResource {\nconst unsigned char *m_data;\nunsigned long long m_size;\nconst char *data() const noexcept {\nreturn (const char *)m_data;\n}\nstd::size_t size() const noexcept {\nreturn (std::size_t)m_size;\n}\nconst char *begin() const noexcept {\nreturn (const char *)m_data;\n}\nconst char *end() const noexcept {\nreturn (const char *)m_data + (std::size_t)m_size;\n}\noperator std::string_view() const noexcept {\nreturn {(const char *)m_data, (std::size_t)m_size};\n}\noperator std::string() const noexcept {\nreturn {(const char *)m_data, (std::size_t)m_size};\n}\nstd::istringstream open() const noexcept {\nreturn std::istringstream{std::string{(const char *)m_data, (std::size_t)m_size}};\n}\nCMakeResource(std::string const &path) {\n")
    get_target_property(build_dir ${target} ARCHIVE_OUTPUT_DIRECTORY)
    if (NOT build_dir)
        set(build_dir ${CMAKE_CURRENT_BINARY_DIR})
    endif()
    foreach(resource ${ARGN})
        # get_filename_component(hash_name "${resource}" NAME)
        # string(REPLACE "-" "_" hash_name "${hash_name}")
        # string(REPLACE "." "_" hash_name "${hash_name}")
        string(MD5 hash_name "${target}\n${build_dir}\n${resource}")
        set(dummy_source ${build_dir}/CMakeResource_${hash_name}.cpp)
        if (NOT EXISTS ${dummy_source} OR ${resource} IS_NEWER_THAN ${dummy_source})
            message(STATUS "Generating CXX resource: ${resource} -> CMakeResource_${hash_name}.cpp")
            file(READ ${resource} hex_contents HEX)
            string(REGEX MATCHALL "([A-Za-z0-9][A-Za-z0-9])" separated_hex "${hex_contents}")
            list(JOIN separated_hex ",\n0x" formatted_hex)
            string(PREPEND formatted_hex "0x")
            file(WRITE ${dummy_source} "/* generated by CMakeResource from [${resource}] */\nnamespace ${namespace} {\nconst unsigned char CMakeResourceData_${hash_name}[] = {\n${formatted_hex},\n0};\nconst unsigned long long CMakeResourceSize_${hash_name} = sizeof(CMakeResourceData_${hash_name});\n}\n")
        endif()
        string(APPEND header_content "if (path == \"${resource}\") {\nextern const unsigned char CMakeResourceData_${hash_name}[];\nextern const unsigned long long CMakeResourceSize_${hash_name};\nm_data = CMakeResourceData_${hash_name};\nm_size = CMakeResourceSize_${hash_name};\nreturn;\n}\n")
        target_sources(${target} PRIVATE ${dummy_source})
    endforeach()
    string(APPEND header_content "throw std::out_of_range(\"CMakeResource path not found\");\n}\n};\n}\n")
    set(resource_header ${build_dir}/CMakeResourceIncludeDir/${header})
    get_filename_component(header_dir ${resource_header} DIRECTORY)
    if (NOT EXISTS ${header_dir})
        file(MAKE_DIRECTORY ${header_dir})
    endif()
    file(WRITE ${resource_header} "${header_content}")
    target_include_directories(${target} ${visibility} ${build_dir}/CMakeResourceIncludeDir)
endfunction()

file(GLOB_RECURSE resources LIST_DIRECTORIES false RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} "data/*")
file(GLOB tests "tests/*.cpp")

add_library(pinyincpp_data STATIC)
target_resources(pinyincpp_data pinyincpp pinyincpp/resources.hpp PUBLIC ${resources})

foreach(file ${tests})
    get_filename_component(name ${file} NAME_WE)
    add_executable(${name} ${file})
    target_link_libraries(${name} pinyincpp_data)
    target_include_directories(${name} PRIVATE include)
endforeach(file)
